#!/usr/bin/env perl
## change the port from 8080 to custom
use lib qw(local);
use XML::Smart;
use Data::Dumper;

my $dir = $0;
$dir =~ s/\/[\w\.-]+$//;
my $POM = "code-generator-pom.xml";
my $pom = "$dir/gen/$POM";
if( ! (-e $pom) ){
    if(!(-d "$dir/gen")){
         print `mkdir $dir/gen`;
    }
    print `cp $dir/$POM $pom`;
}


## get args
my $domain = shift @ARGV;
my $cmd = shift @ARGV;

my $dump=undef;
my $save=undef;
foreach(@ARGV){
  if(/--dump/){
    $dump=1
  }
  if(/--save/){
    $save=1
  }
}

sub usage {
    print "Usage: \n";
    print "   conf-cli table reset\n";
    print "   conf-cli table list [--dump] [--save]\n";
    print "   conf-cli table add <table>  [...]\n";
    print "   conf-cli crud  reset\n";
    print "   conf-cli crud  list\n";
    print "   conf-cli crud  add one      <master>\n";
    print "   conf-cli crud  add onemany  <master> <slave> [...]\n";
    print "   conf-cli crud  add manymany <master> <peer>  <relation>\n";
    print "   conf-cli crud  add group    <group>  [by]\n";
}

if( !$cmd ){
   usage();
   exit(0);
}
if($domain =~ /^table$/){
   ## ok
   if($cmd =~ /^add$/){
      my $args = @ARGV;
      if($args==0){
         usage;
         exit;
      }
   }elsif($cmd =~ /^list$/){
   }elsif($cmd =~ /^reset$/){
   }else{
      usage;
      exit;
   }
}
elsif ($domain =~ /^crud$/){
    ## ok
    if($cmd =~ /^list$/){
       ## ok
    }elsif($cmd =~ /^reset$/){
       ## ok
    }elsif($cmd =~ /^add$/){
       ## ok
       my $op = $ARGV[0];
       if($op =~ /^one$/){
          ## ok
          if (@ARGV==1){
             print "Usage: conf-cli crud add one <table>\n";
             exit(0);
          }
       }else{
          print "Usage: conf-cli crud add one <table>\n";
          exit(0);
       }
    } 
    elsif($cmd =~ /^onemany$/){
       ## ok
    }
    elsif($cmd =~ /^manymany$/){
       ## ok
    }else{
       usage();
       exit();
    }
   
}else{
   usage();
   exit(0);
}


my $XML = XML::Smart->new($pom);
#$XML = $XML->cut_root ;
#my $connector = $XML->{Service}[0]{Connector}("protocol", "eq", "HTTP/1.1");
#my $port = $connector->{port};


## 
if($domain =~ /^table$/){
    if($cmd =~ /list/){
        &table_list;
       
    }elsif ($cmd =~ /add/){
       my @tabs = @ARGV;
       &table_add(\@tabs);
       &table_list;
       
    }elsif ($cmd =~ /reset/){
       &table_reset();
       &table_list;
    }
    
}elsif($domain =~ /^crud$/){

    if($cmd =~ /^list$/){
        &crud_list;
        
    }elsif($cmd =~ /^reset$/){
        &crud_reset;
        &crud_list;

    }elsif($cmd =~ /^add$/){

        my $crud_mask = shift @ARGV;

        if($crud_mask =~ /one/){
            my $master = shift @ARGV;
            crud_add_one($master);
            &crud_list;
           
        }elsif ($crud_mask =~ /onemany/){
            my $master = shift @ARGV;
            my @slaves = @ARGV;

            crud_add_onemany($master, \@slaves);
            &crud_list;
           
        }elsif ($crud_mask =~ /manymany/){
            my $master = shift @ARGV;
            my $peer = shift @ARGV;
            my $relation = shift @ARGV;

            crud_add_manymany($master, $peer, $relation);
            &crud_list;
           
        }
    }
}


if($dump){
## get or chng server port
##$connector->{port} = $server_port;
print "\n##############################################\n";
print Dumper($XML->data);
print "\n##############################################\n";
}
if($save){
   $XML->save($pom);
}

########################################
## Table Domain
########################################
sub table_list {
    # my @tables =  $XML->{project}{build}{plugins}{plugin}{configuration}{tables}->nodes;
    # my $TABLES = &create_table(\@tables);
    # my $data = Dumper($TABLES->data);
    # my @lines = split(/\n/,$data);
    # foreach(@lines){
    #    if(/table/){
    #       print;
    #       print "\n";
    #    }
    # }

    # return;
    
    my $tables_node =  $XML->{project}{build}{plugins}{plugin}{configuration}{tables};
    my @tables = @{$tables_node->{table}};

    my $TABLES_NEW = XML::Smart->new();
    $TABLES_NEW = $TABLES_NEW->{tables};

    foreach(@tables){
       push(@{$TABLES_NEW->{table}}, $_);
    }

    ## dump data
    my $data = Dumper($TABLES_NEW->data);

    my @lines = split(/\n/,$data);
    foreach(@lines){
        if(/meta/ || /xml/ || /[\$;]/){
            next;
        }
        print;
        print "\n";
    }
}

sub table_add {
    my ($tabs_ref) = @_;
    my @tabs = @{$tabs_ref};
 
    my $tables_node =  $XML->{project}{build}{plugins}{plugin}{configuration}{tables};

    foreach(@tabs){
;        my $table_new = XML::Smart->new();
        $table_new->{table}->content(0, $_);

        push(@{$tables_node->{table}}, $table_new->nodes);
    }
}

sub table_reset {
    my $tables_ref =  $XML->{project}{build}{plugins}{plugin}{configuration};
    my @empty=();
    $tables_ref->{tables} = \@empty;
}



########################################
## CRUD Domain 
########################################
sub crud_list {

   my $cruds_node =  $XML->{project}{build}{plugins}{plugin}{configuration}{cruds};
   my @cruds = @{$cruds_node->{crud}};

   my $CRUDS_NEW = XML::Smart->new();
   $CRUDS_NEW = $CRUDS_NEW->{cruds};

   foreach(@cruds){
       push(@{$CRUDS_NEW->{crud}}, $_);
   }

    ## dump data
    my $data = Dumper($CRUDS_NEW->data);

    my @lines = split(/\n/,$data);
    foreach(@lines){
        if(/meta/ || /xml/ || /[\$;]/){
            next;
        }
        print;
        print "\n";
    }
}

sub crud_reset {
    my $configuration =  $XML->{project}{build}{plugins}{plugin}{configuration};
    my @empty=();
    $configuration->{cruds} = \@empty;
}

sub crud_add_one {
   my($tab) = @_;

   my $cruds_node =  $XML->{project}{build}{plugins}{plugin}{configuration}{cruds};

   ## build hash for create_crud
   my $hash = {};
   $hash->{mask} = 'master';
   $hash->{master} = $tab;

   my $crud = &create_crud($hash);
   $crud = $crud->cut_root;

   push(@{$cruds_node->{crud}}, $crud->pointer);
}

sub crud_add_onemany {

}

sub crud_add_manymany{

}

########################################
## TABLE Builder 
########################################
sub create_table {
    my ($tabs_ref) = @_;
    my @tabs = @{$tabs_ref};
    
    my $TABLES = XML::Smart->new();
        my $one = $TABLES->{tables};

       if(@tabs > 1){
           foreach(@tabs){
              push(@{$one->{table}}, $_);
           }
       }else{
           $one->{table}->content(0, $tabs[0]);
       }

    return $TABLES;
}

########################################
## CRUD Builder 
########################################
sub create_crud {
    my ($hash) = @_;
    # $hash = $crud_ref->pointer_ok;

    my $CRUD = XML::Smart->new();

        my $node = $CRUD->{crud};

        if( exists $hash->{mask}){
            my $mask = $hash->{mask};
            $node->{mask}->content(0, $mask);
        }

        if(exists $hash->{master}){
            my $master = $hash->{master};
           $node->{master}->content(0, $master);
        }

        if(exists $hash->{masterId}){
            my $masterId = $hash->{masterId};
           $node->{masterId}->content(0, $masterId);
        }

        # CHILDREN
        if(exists $hash->{children}){
            my @nodes = $hash->{children}->nodes;

            foreach(@nodes){
                push(@{$node->{children}->{child}}, $_);
            }
        }

        # SLAVES
        if(exists $hash->{slaves}){
            my @nodes = $hash->{slaves}->nodes;

            foreach(@nodes){
                push(@{$node->{slaves}->{slave}}, $_);
            }
        }

        # PEER
        if(exists $hash->{masterPeer}){
            my $masterPeer = $hash->{masterPeer};
           $node->{masterPeer}->content(0, $masterPeer);
        }

        if(exists $hash->{relation}){
            my $relation = $hash->{relation};
           $node->{relation}->content(0, $relation);
        }

        # GROUP
        if(exists $hash->{group}){
            my $group = $hash->{group};
           $node->{group}->content(0, $group);
        }

        if(exists $hash->{groupBy}){
            my $groupBy = $hash->{groupBy};
           $node->{groupBy}->content(0, $groupBy);
        }
        
    return $CRUD;
}




